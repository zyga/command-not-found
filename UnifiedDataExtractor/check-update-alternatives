#!/usr/bin/env python3
# Copyright 2013 Canonical Ltd.
#
# Written by:
#   Zygmunt Krynicki <zygmunt.krynicki@canonical.com>
#
# Licensed under GPL, see COPYING for the whole text

from argparse import ArgumentParser
from collections import OrderedDict
from configparser import ConfigParser
import hashlib
import json
import logging
import os
import shlex
import sys

import DebPackage


def join_line_continuations(script):
    """
    Join shell-like line continuations

    line \
    rest

    Gets joined to 'line rest'
    """
    full_line = None
    for line in script.splitlines():
        if full_line is None:
            full_line = line
        else:
            full_line += ' '
            full_line += line
        if line.endswith("\\"):
            full_line = full_line.rstrip('\\')
            continue
        yield full_line
        full_line = None
    if full_line is not None:
        yield full_line


class Scanner:

    def __init__(self):
        self.db = ConfigParser(dict_type=OrderedDict)
        self._older_answer = {}  # hashed_hint_list -> yes|no

    def scan_pkg(self, filename, wanted_token="update-alternatives"):
        """
        Scan the given debian binary package.

        This scans the control file, looks for any mention of
        update-alternatives and updates the database, if necessary.

        Each package (identified uniquely as name and version) is either marked
        as a TODO or is verified manually. If there is no manual verification
        a TODO record is generated.
        """
        # Load the package
        try:
            package = DebPackage.load(filename)
        except Exception:
            logging.exception("unable to process package %s", filename)
            return
        else:
            logging.info("processing package %s from %s", package, filename)
        # Access the postinst script
        postinst = package.getControlFile("postinst")
        if postinst is None:
            # Print a simple progress indicator for each file we scan
            print(".", end='')
            sys.stdout.flush()
            return
        postinst = postinst.decode(errors='replace')
        # Skip packages that don't have the keyword we are looking for in the
        # postinst script.
        if wanted_token not in postinst:
            print("o", end='')
            sys.stdout.flush()
            return
        # Build an identifier for the package
        package_id = str(package)
        # If the package needs manual checks, skip it
        if self.db.get(package_id, "manual-check", fallback=None) == "yes":
            print("m", end='')
            sys.stdout.flush()
            return
        # if this package already has alternatives, skip it:
        if self.db.get(package_id, "alternatives", fallback=None) is not None:
            print("g", end='')
            sys.stdout.flush()
            return
        # If the package does not have a section, add one
        if not self.db.has_section(package_id):
            self.db.add_section(package_id)
        # Get possible hints
        hint_list = list(self._get_hint_list(postinst, wanted_token))
        hashed_hint_list = self._get_hint_list_hash(hint_list)
        # If the hint list is empty, mark this as broken
        if len(hint_list) == 0:
            logging.info("package %s got empty hints", package)
            # Indicate that the hint list was empty despite having seen
            # update-alternatives in the script
            self.db.set(package_id, "empty-hints", "yes")
            # Mark for manual inspection
            self.db.set(package_id, "manual-check", "yes")
            print("h", end='')
            sys.stdout.flush()
            return
        # Check if any hints are using variables
        for link, path in hint_list:
            # If there are variables, mark as required manual work
            # Don't bother asking the user if we guessed right.
            if '$' in link or '$' in path:
                logging.info("package %s uses variables", package)
                # Store the hash of the hint
                self.db.set(package_id, "hint-hash", hashed_hint_list)
                # Indicate that the hint contained variables
                self.db.set(package_id, "uses-variables", "yes")
                # Mark for manual inspection
                self.db.set(package_id, "manual-check", "yes")
                print("v", end='')
                sys.stdout.flush()
                return
        # Check if we got an answer for that hint list before
        older_answer = self._older_answer.get(hashed_hint_list)
        if older_answer == "yes":
            # Store the hash of the hint
            self.db.set(package_id, "hint-hash", hashed_hint_list)
            # Use hints as the list of alternatives
            self.db.set(
                package_id, "alternatives",
                " ".join([
                    "{0}={1}".format(link, path)
                    for link, path in hint_list]))
            # Indicate that we've reused previous answer for this hint
            self.db.set(package_id, "using-hint", "yes")
            print("a", end='')
            sys.stdout.flush()
            return
        # Check if we got an answer for that hint list before
        elif older_answer == "no":
            # Store the hash of the hint
            self.db.set(package_id, "hint-hash", hashed_hint_list)
            # Mark as needing manual checks
            self.db.set(package_id, "manual-check", "yes")
            # Indicate that we've reused previous answer for this hint
            self.db.set(package_id, "using-hint", "yes")
            print("A", end='')
            sys.stdout.flush()
            return
        # Now we need to ask the user if we've guessed right
        print()
        answered = False
        while not answered:
            print("Given this script")
            print("v" * 80)
            print(postinst)
            print("^" * 80)
            print("And those automatically-detected alternatives:")
            for link, path in hint_list:
                print("  {0}={1}".format(link, path))
            print("Are the alternatives correct?")
            choice = input("yes,no,[skip] > ")
            if choice in ('', 's', 'skip'):
                answered = True
            elif choice in ('y', 'yes'):
                answered = True
                # Store the list of alternatives
                self.db.set(
                    package_id, "alternatives",
                    " ".join([
                        "{0}={1}".format(link, path)
                        for link, path in hint_list]))
                # Store the hash of the hint
                self.db.set(package_id, "hint-hash", hashed_hint_list)
                # Indicate that the hint was correct
                self.db.set(package_id, "hint-correct", "yes")
                self._older_answer[hashed_hint_list] = "yes"
            elif choice in ('n', 'no'):
                answered = True
                # Mark for manual inspection
                self.db.set(package_id, "manual-check", "yes")
                # Store the hash of the hint
                self.db.set(package_id, "hint-hash", hashed_hint_list)
                # Indicate that the hint was incorrect
                self.db.set(package_id, "hint-correct", "no")
                self._older_answer[hashed_hint_list] = "no"

    def load_db(self, filename):
        """
        Load database of update-alternatives annotations from a file
        """
        # Load the database from the file
        logging.info("Loading database from %s", filename)
        self.db.read([filename], encoding='UTF-8')
        # Reset known answers
        self._older_answer = {}
        # Rebuild answers based on hint_hash and hint_answer key that were
        # tagged as automatic. This helps us not ask the same question twice.
        for package_id in self.db.sections():
            hint_hash = self.db.get(
                package_id, "hint-hash", fallback=None)
            hint_answer = self.db.get(
                package_id, "hint-correct", fallback=None)
            if hint_hash is not None and hint_answer in ("yes", "no"):
                self._older_answer[hint_hash] = hint_answer

    def save_db(self, filename):
        """
        Save the database of update-alternatives annotations to a file
        """
        logging.info("Saving database to %s", filename)
        with open(filename, 'wt', encoding='UTF-8') as stream:
            self.db.write(stream)

    def print_legend(self):
        print("Legend:")
        print("  . - package without a postinst script")
        print("  o - package without 'update-alternatives' in postint script")
        print("  m - package that needs manual check (no change)")
        print("  g - package that has good data (no change)")
        print("  a - package handled based on earlier correct guess")
        print("  A - package handled based on earlier incorrect guess")
        print("  v - package skipped due to shell variables used with 'update-alternatives'")
        print("  h - package skipped due to no hints despite seeing 'update-alternatives'")

    def _get_hint_list(self, script, wanted_token):
        """
        Get hints for update-alternatives in the specified script

        This method generates pairs (link, path) for each possible candidate.
        """
        for line in join_line_continuations(script):
            # Strip comments
            try:
                line = line[line.index("#")].rstrip()
            except ValueError:
                pass
            if wanted_token not in line:
                continue
            # Parse one of two ways update-alternatives gets called
            token_iter = iter(shlex.split(line))
            for token in token_iter:
                if token == 'update-alternatives':
                    continue
                elif token in ('--install', '--slave'):
                    link = next(token_iter)
                    next(token_iter)
                    path = next(token_iter)
                    yield link, path
                    continue

    def _get_hint_list_hash(self, hint_list):
        """
        Get a hash representation of the list of hints
        """
        return hashlib.sha1(
            json.dumps(hint_list).encode("ASCII")
        ).hexdigest()


def main():
    parser = ArgumentParser()
    parser.add_argument(
        'archive', help="path to the archive to scan")
    parser.add_argument(
        "db", help="path to the database to amend")
    ns = parser.parse_args()
    scanner = Scanner()
    if os.path.exists(ns.db):
        scanner.load_db(ns.db)
    scanner.print_legend()
    try:
        print("Scanning {0}".format(ns.archive))
        for dirpath, dirnames, filenames in os.walk(ns.archive):
            for filename in filenames:
                if filename.endswith('.deb'):
                    scanner.scan_pkg(os.path.join(dirpath, filename))
    finally:
        scanner.save_db(ns.db)

if __name__ == "__main__":
    logging.basicConfig(
        level=logging.DEBUG,
        filename="check-update-alternatives.log",
        format='%(levelname)s %(message)s',
        filemode='wt')
    try:
        main()
    except KeyboardInterrupt:
        pass
